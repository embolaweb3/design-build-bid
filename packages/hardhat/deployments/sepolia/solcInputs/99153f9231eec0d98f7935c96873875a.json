{
  "language": "Solidity",
  "sources": {
    "contracts/DesignBuildBid.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract DesignBuildBid {\n\n    // Struct to represent a project\n    struct Project {\n        uint id;\n        address owner;\n        string description;\n        uint budget;\n        uint deadline;\n        bool active; // Indicates if the project is active\n        address selectedBidder; // Address of the selected bidder\n        uint[] milestones; // Array of milestone amounts\n        bool[] milestonePaid; // Tracks if each milestone is paid\n        bool disputeRaised; // Indicates if a dispute is raised\n        uint selectedBidIndex; // Index of the selected bid\n    }\n\n    // Struct to represent a bid\n    struct Bid {\n        uint projectId;\n        address bidder;\n        uint bidAmount;\n        uint completionTime; // Proposed completion time by the bidder\n        uint[] proposedMilestones; // Milestones proposed by the bidder\n        bool selected; // Indicates if the bid is selected\n    }\n\n    // Struct to represent a dispute\n    struct Dispute {\n        uint projectId;\n        address disputant;\n        string reason;\n        mapping(address => bool) votes; // Mapping to track votes on the dispute\n        uint yesVotes; // Count of yes votes\n        uint noVotes; // Count of no votes\n        bool resolved; // Indicates if the dispute is resolved\n    }\n\n    // State variables to track counts and mappings\n    uint public projectCount;\n    uint public bidCount;\n    uint public disputeCount;\n\n    mapping(uint => Project) public projects; // Maps project ID to Project struct\n    mapping(uint => Bid[]) public bids; // Maps project ID to an array of bids\n    mapping(uint => Dispute) public disputes; // Maps dispute ID to Dispute struct\n\n    // Events to log significant actions\n    event ProjectPosted(uint projectId, address owner, string description, uint budget, uint deadline);\n    event BidSubmitted(uint bidId, uint projectId, address bidder, uint bidAmount, uint completionTime);\n    event BidSelected(uint projectId, address selectedBidder);\n    event MilestonePaid(uint projectId, uint milestoneIndex);\n    event DisputeRaised(uint disputeId, uint projectId, address disputant, string reason);\n    event DisputeResolved(uint disputeId, bool result);\n\n    // Modifier to restrict access to only the project owner\n    modifier onlyProjectOwner(uint _projectId) {\n        require(msg.sender == projects[_projectId].owner, \"Only the project owner can perform this action\");\n        _;\n    }\n\n    // Modifier to restrict access to only the selected bidder\n    modifier onlySelectedBidder(uint _projectId) {\n        require(msg.sender == projects[_projectId].selectedBidder, \"Only the selected bidder can perform this action\");\n        _;\n    }\n\n    // Function for the project owner to post a new project\n    function postProject(string memory _description, uint _budget, uint _deadline, uint[] memory _milestones) public {\n        require(_milestones.length > 0, \"There must be at least one milestone\");\n        projectCount++;\n        projects[projectCount] = Project(projectCount, msg.sender, _description, _budget, _deadline, true, address(0), _milestones, new bool[](_milestones.length), false, 0);\n        emit ProjectPosted(projectCount, msg.sender, _description, _budget, _deadline);\n    }\n\n    // Function for contractors to submit bids for a project\n    function submitBid(uint _projectId, uint _bidAmount, uint _completionTime, uint[] memory _proposedMilestones) public {\n        require(projects[_projectId].active, \"Project is not active\");\n        require(_proposedMilestones.length == projects[_projectId].milestones.length, \"Milestones count mismatch\");\n\n        bidCount++;\n        bids[_projectId].push(Bid(_projectId, msg.sender, _bidAmount, _completionTime, _proposedMilestones, false));\n        emit BidSubmitted(bidCount, _projectId, msg.sender, _bidAmount, _completionTime);\n    }\n\n    // Function for the project owner to select a bid\n    function selectBid(uint _projectId, uint _bidIndex) public onlyProjectOwner(_projectId) {\n        require(bids[_projectId][_bidIndex].bidder != address(0), \"Bid does not exist\");\n        require(!projects[_projectId].disputeRaised, \"Cannot select bid during dispute\");\n\n        projects[_projectId].selectedBidder = bids[_projectId][_bidIndex].bidder;\n        bids[_projectId][_bidIndex].selected = true;\n        projects[_projectId].active = false; // Project becomes inactive after a bid is selected\n        projects[_projectId].selectedBidIndex = _bidIndex;\n        emit BidSelected(_projectId, bids[_projectId][_bidIndex].bidder);\n    }\n\n    // Function to release payment for a specific milestone\n    function releaseMilestonePayment(uint _projectId, uint _milestoneIndex) public onlyProjectOwner(_projectId) {\n        require(projects[_projectId].selectedBidder != address(0), \"No bid selected\");\n        require(!projects[_projectId].milestonePaid[_milestoneIndex], \"Milestone already paid\");\n        require(_milestoneIndex < projects[_projectId].milestones.length, \"Invalid milestone index\");\n        require(!projects[_projectId].disputeRaised, \"Cannot release payment during dispute\");\n\n        uint payment = projects[_projectId].milestones[_milestoneIndex];\n        projects[_projectId].milestonePaid[_milestoneIndex] = true;\n        (bool success,) = payable(projects[_projectId].selectedBidder).call{value : payment}(\"\");\n        require(success, 'Transfer failed');\n        emit MilestonePaid(_projectId, _milestoneIndex);\n    }\n\n    // Function for the selected bidder to raise a dispute\n    function raiseDispute(uint _projectId, string memory _reason) public onlySelectedBidder(_projectId) {\n        require(!projects[_projectId].disputeRaised, \"Dispute already raised for this project\");\n\n        disputeCount++;\n        Dispute storage dispute = disputes[disputeCount];\n        dispute.projectId = _projectId;\n        dispute.disputant = msg.sender;\n        dispute.reason = _reason;\n        projects[_projectId].disputeRaised = true;\n        emit DisputeRaised(disputeCount, _projectId, msg.sender, _reason);\n    }\n\n    // Function for stakeholders to vote on a dispute\n    function voteOnDispute(uint _disputeId, bool _vote) public {\n        require(!disputes[_disputeId].resolved, \"Dispute already resolved\");\n        require(!disputes[_disputeId].votes[msg.sender], \"You have already voted on this dispute\");\n\n        disputes[_disputeId].votes[msg.sender] = true;\n        if (_vote) {\n            disputes[_disputeId].yesVotes++;\n        } else {\n            disputes[_disputeId].noVotes++;\n        }\n\n        // Resolve the dispute if a majority vote is reached\n        if (disputes[_disputeId].yesVotes > disputes[_disputeId].noVotes) {\n            disputes[_disputeId].resolved = true;\n            _resolveDispute(_disputeId, true);\n        } else if (disputes[_disputeId].noVotes > disputes[_disputeId].yesVotes) {\n            disputes[_disputeId].resolved = true;\n            _resolveDispute(_disputeId, false);\n        }\n    }\n\n    // Internal function to handle dispute resolution\n    function _resolveDispute(uint _disputeId, bool result) internal {\n        uint projectId = disputes[_disputeId].projectId;\n        projects[projectId].disputeRaised = false;\n        emit DisputeResolved(_disputeId, result);\n    }\n\n    // Function to fetch all projects\n    function fetchProjects() public view returns (Project[] memory) {\n        Project[] memory allProjects = new Project[](projectCount);\n        for (uint i = 1; i <= projectCount; i++) {\n            allProjects[i - 1] = projects[i];\n        }\n        return allProjects;\n    }\n\n    // Function for the project owner to withdraw unspent funds\n    function withdrawUnspentFunds(uint _projectId) public onlyProjectOwner(_projectId) {\n        require(!projects[_projectId].active, \"Project is still active\");\n        require(!projects[_projectId].disputeRaised, \"Cannot withdraw during a dispute\");\n\n        uint unspentAmount = address(this).balance;\n        for (uint i = 0; i < projects[_projectId].milestones.length; i++) {\n            if (!projects[_projectId].milestonePaid[i]) {\n                unspentAmount -= projects[_projectId].milestones[i];\n            }\n        }\n\n        require(unspentAmount > 0, \"No unspent funds available\");\n        (bool success,) = payable(projects[_projectId].owner).call{value: unspentAmount}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    // Function to allow the project owner to cancel a project\n    function cancelProject(uint _projectId) public onlyProjectOwner(_projectId) {\n        require(projects[_projectId].active, \"Project is not active or already completed\");\n        require(projects[_projectId].selectedBidder == address(0), \"Cannot cancel after a bid has been selected\");\n\n        projects[_projectId].active = false;\n\n        // Refund all bidders\n        for (uint i = 0; i < bids[_projectId].length; i++) {\n            (bool success,) = payable(bids[_projectId][i].bidder).call{value: bids[_projectId][i].bidAmount}(\"\");\n            require(success, \"Refund failed\");\n        }\n    }\n\n    // Function to allow the project owner to update project details\n    function updateProject(uint _projectId, string memory _description, uint _budget, uint _deadline, uint[] memory _milestones) public onlyProjectOwner(_projectId) {\n        require(projects[_projectId].active, \"Project is not active\");\n        require(projects[_projectId].selectedBidder == address(0), \"Cannot update after a bid has been selected\");\n\n        projects[_projectId].description = _description;\n        projects[_projectId].budget = _budget;\n        projects[_projectId].deadline = _deadline;\n        projects[_projectId].milestones = _milestones;\n        projects[_projectId].milestonePaid = new bool[](_milestones.length);\n    }\n\n    // Function to extend the project deadline\n    function extendDeadline(uint _projectId, uint _newDeadline) public {\n        require(msg.sender == projects[_projectId].owner || msg.sender == projects[_projectId].selectedBidder, \"Only project owner or selected bidder can extend the deadline\");\n        require(_newDeadline > projects[_projectId].deadline, \"New deadline must be later than the current deadline\");\n        require(!projects[_projectId].disputeRaised, \"Cannot extend deadline during dispute\");\n\n        projects[_projectId].deadline = _newDeadline;\n    }\n\n    // Function to penalize the selected bidder for missing the deadline\n    function penalizeBidder(uint _projectId) public onlyProjectOwner(_projectId) {\n        require(projects[_projectId].selectedBidder != address(0), \"No bidder selected\");\n        require(block.timestamp > projects[_projectId].deadline, \"Deadline not yet reached\");\n        require(!projects[_projectId].milestonePaid[projects[_projectId].milestones.length - 1], \"All milestones already paid\");\n\n        uint penalty = projects[_projectId].budget / 10; // Example: 10% penalty\n        projects[_projectId].milestones[projects[_projectId].milestones.length - 1] -= penalty;\n\n        (bool success,) = payable(projects[_projectId].owner).call{value: penalty}(\"\");\n        require(success, \"Penalty transfer failed\");\n    }\n\n    // Fallback function to accept Ether\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}